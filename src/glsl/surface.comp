#version 460 core

layout (local_size_x = 16, local_size_y = 4, local_size_z = 1) in;

readonly buffer density_block
{
    float density[];
};

struct Vert {
    vec3 pos;
    uint rgba;
};

writeonly buffer surface_block // TODO layout(std430) ?
{
    Vert surface[];
};

layout(binding = 0) uniform atomic_uint index;

uniform uint chunk_size;
uniform float mip_scale;
uniform vec3 offset;

// Simplex 3D Noise
// by Ian McEwan, Ashima Arts
// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83

vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float simplexNoise(vec3 v)
{
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    // x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
    i = mod(i, 289.0);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0)) +
        i.y + vec4(0.0, i1.y, i2.y, 1.0)) +
        i.x + vec4(0.0, i1.x, i2.x, 1.0));

    // Gradients
    // (N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0 / 7.0; // N=7
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_); // mod(j, N)

    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);

    // Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}

vec3 sampleColour(vec3 pos)
{
    vec3 colour = vec3(0);
    for (uint c = 0; c < 3; ++c)
    {
        vec3 c_pos = pos;
        c_pos[c] += chunk_size * 99;
        colour[c] += (simplexNoise(c_pos / chunk_size / 2) + 1) / 2;
    }
    return colour;
}

bool fullIndex(uint id)
{
    return density[id] > 0;
}

bool emptyIndex(uint id)
{
    return !fullIndex(id);
}

uint indexFromPos(vec3 _pos)
{
    const uint size = chunk_size / uint(mip_scale);
    const vec3 pos = _pos; // floor((_pos + vec3(size / 2)) / mip_scale);
    uint index = 0;

    for (uint d = 0; d < 3; ++d)
    {
        const uint i = 2 - d;
        if (pos[i] < 0 || pos[i] >= size) return ~0; // Position is outside chunk
        index *= size;
        index += uint(pos[i]);
    }

    return index;
}

bool fullPos(vec3 pos)
{
    uint index = indexFromPos(pos);
    if (index == ~0) return false; // TODO query neighbours
    // TODO if mip_level != 0 and we are not calculating occlusion, return false
    return fullIndex(index);
}

void main()
{
    // Calculate the index of density that corresponds to this thread
    const vec3 num_threads = gl_NumWorkGroups * gl_WorkGroupSize;
    const uint id = uint(dot(
        gl_GlobalInvocationID,
        vec3(1, num_threads.x, num_threads.y * num_threads.x)
    ));
    // Skip empty cubes
    if (emptyIndex(id)) return;
    // Faces
    const vec3 pos = gl_GlobalInvocationID;
    for (uint f = 0; f < 6; ++f)
    {
        vec3 neighbour = pos;
        neighbour[f / 2] += (f % 2 > 0) ? mip_scale : -mip_scale;
        if (fullPos(neighbour)) continue;
        // Sample voxel occlusion
        bool occlusion[8];
        for (uint e = 0; e < 4; ++e)
        {
            // Voxels that share edges
            vec3 occluder = neighbour;
            occluder[(e / 2 + f / 2 + 1) % 3] += (e % 2 > 0) ? mip_scale : -mip_scale;
            occlusion[e] = fullPos(occluder);
            // Voxels that share corners
            occluder = neighbour;
            occluder[(f / 2 + 1) % 3] += (e % 2 > 0) ? mip_scale : -mip_scale;
            occluder[(f / 2 + 2) % 3] += (e / 2 > 0) ? mip_scale : -mip_scale;
            occlusion[e + 4] = fullPos(occluder);
        }
        uint i = atomicCounterAdd(index, 2 * 3);
        // Triangles
        for (uint t = 0; t < 2; ++t)
        {
            // Vertices
            for (uint v = 0; v < 3; ++v)
            {
                vec3 vert = (pos + neighbour) / 2 - vec3(chunk_size / uint(mip_scale) / 2);
                const bool x = (t + v + f) % 2 > 0;
                const bool y = v / 2 == t;
                vert[(f / 2 + 1) % 3] += (x ? mip_scale : -mip_scale) / 2;
                vert[(f / 2 + 2) % 3] += (y ? mip_scale : -mip_scale) / 2;
                // Vertex positions
                surface[i].pos = vert;
                vec3 colour = sampleColour(vert + offset);
                float occ = 0;
                if (occlusion[x ? 1 : 0]) occ += 1;
                if (occlusion[y ? 3 : 2]) occ += 1;
                if (occlusion[4 + (x ? 1 : 0)
                                + (y ? 2 : 0)]) occ += 1;
                colour /= pow(1.1, occ);
                surface[i].rgba = packUnorm4x8(vec4(colour, 1));
                ++i;
            }
        }
    }
}
